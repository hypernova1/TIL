# 연산자

연산이란 프로그래밍에서 데이터를 처리하고 결과를 산출하는 것을 말합니다. 이때 사용되는 기호가 바로 연산자입니다. 그리고 연산의 대상이 되는 것이 바로 피연산자입니다.

~~~
1 + 2
~~~

위와 같은 식이 있다고 할 때 `+`는 연산을 하는 연산자, `1`과 `2`는 연산의 대상인 피연산자입니다.  

프로래밍에서는 일반적인 수학적 연산 이외에도 다양한 연산이 존재합니다. 기본적인 산술 연산자를 시작으로 하나씩 알아보도록 합시다.

## 산술 연산자

### 일반적인 산술 연산자

산술 연산자란 우리가 직관적으로 알고 있는 수학적 연산을 행하는 연산자입니다. 덧셈, 뺄셈, 곱셈, 나눗셈 그리고 나머지 연산(mod)이 있습니다.

~~~java
int sum = 1 + 2; //덧셈
int sub = 4 - 2; //뺄셈
int mul = 5 * 3; //곱셈
int div = 5 / 2; //나눗셈
int mod = 7 % 5; //나머지 연산(mod)
~~~

우리가 일상적으로 사용하는 덧셈, 뺄셈, 곱셈, 나눗셈의 경우는 일반적인 상식대로 사용하면 됩니다. 하지만 나머지 연산은 `%` 연산자를 사용하며 앞에 있는 숫자를 뒤에 있는 숫자로 나눈 뒤 나머지를 반환합니다. 위의 니머지 연산에서 결과 값은 2가 됩니다. 하지만 주의할 점이 있습니다. **리터럴로 값을 연산하면 int형으로 반환**이 된다는 것입니다. 따라서 위의 나눗셈과 같이 나머지가 필요한 경우에는 **하나의 값 이상을 `double` 또는 `float`으로 변환을 시킨 후 연산**을 해야합니다. 다음의 예제를 통해 확인해 봅시다.

~~~java
double result = 2 / 4;
System.out.print(result); //0
~~~

결과 값을 `double`로 받았으니 당연히 `0.5`가 들어갈 것 같습니다. 하지만 결과 값을 확인해보면 `0`이 나오게 됩니다. **연산시 기본적으로 int 타입으로 반환하기 때문**인데요. `int`는 소수점을 사용할 수 없는 타입이기 때문에 소숫점 이하는 버려지게 됩니다. 따라서 다음과 같이 변경하여 제대로된 결과 값을 얻을 수 있습니다.

~~~java
double result = (double) 2 / 4;
//or
double result = 2 / (double) 4;

System.out.prin(result); //0.5
~~~

[2번째 과제](https://github.com/hypernova1/TIL/tree/master/java/live-study/2.%20%EC%9E%90%EB%B0%94%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%2C%20%EB%B3%80%EC%88%98%20%EA%B7%B8%EB%A6%AC%EA%B3%A0%20%EB%B0%B0%EC%97%B4)에서 학습했듯이 타입 프로모션 때문입니다. 큰 타입과 작은 타입을 연산을 했을때 결과의 타입은 큰 타입으로 나오게 됩니다.

### 증감 연산자

프로그래밍 언어에서는 일반적인 산술 연산자 이외에 **증감 연산자**라는 것도 존재합니다. 증감 연산자는 피연산자 앞뒤에 붙어서 피연산자를 1 증가 시키거나 감소시킵니다. 연산자가 앞에 붙으면 **전위 증감 연산자**, 뒤에 붙으면 **후위 증감 연산자**라고 합니다.

~~~java
int num = 0;

int preSum = ++num; //전위 증가 연산자
int postSum = num++;//후위 증가 연산자

int preSub = --num; //전위 감소 연산자
int postSub = num--;//후위 감소 연산자
~~~

전위/후위 증감 연산자는 모두 값을 1 증가 시키거나 감소시킨다고 했습니다. 그렇다면 어떤 차이가 있길래 구분하여 사용하는 것일까요? 바로 증감을 언제 시키느냐에 따라 다르게 사용됩니다. 전위 증감 연산자는 해당 피연산자의 값을 증감 시킨 후 변수에 할당하도록 하고, 후위 증감 연산자는 할당 후 값을 증감시킵니다.

~~~java
//전위
int num = 0;
int preSum = ++num;
System.out.print(preSum); //1

//후위
int num = 0;
int postSum = num++;
System.out.print(postSum); //0
~~~

## 대입(`=`) 연산자

대입 연산자는 `=`기호를 중심으로 오른쪽의 피연산자를 왼쪽의 변수에 대입하도록 하는 연산자입니다. 단순히 값을 대입하는 대입 연산자와 변수의 값과 우측의 피연산자를 연산 후 대입하는 복합 대입 연산자가 있습니다.

### 대입 연산자의 사용 예

아래의 예제와 같이 변수의 우측에 대입 연산자를 쓴 뒤, 변수에 대입할 값을 쓰면 됩니다. 변수 선언과 동시에 대입하거나 변수를 선언한 후에 대입할 수 있습니다.

~~~java
int num = 3;
//or
int num;
num = 3;
~~~

또한 우측에서 좌측으로 대입된 다는 점을 이용하여 다음과 같이 연쇄적으로 사용할 수 있습니다. 이 경우는 변수 선언과 동시에 할당은 할 수 없습니다.

~~~java
int x, y, z;

x = y = z = 3;

System.out.println(x); //3
System.out.println(y); //3
System.out.println(z); //3

int x, y, z = 3; //error
~~~

### 복합 대입 연산자

복합 대입 연산자는 **변수와 값을 산술 연산하거나 논리 연산을 한 후, 변수에 바로 대입해주는 연산자**입니다. 연산자 뒤에 대입 연산자를 붙여 사용하면 됩니다. 왼쪽의 피연산자(변수)를 오른쪽의 피연산자를 연산한 후 다시 대입합니다.

|연산자|설명|예|
|--|--|--|
|`+=`|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후 대입|num += 2|
|`-=`|왼쪽의 피연산자에 오른쪽의 피연산자를 뺀 후 대입|num -= 2|
|`*=`|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후 대입|num *= 2|
|`/=`|왼쪽의 피연산자에 오른쪽의 피연산자를 나눈 후 대입|num /= 2|
|`%=`|왼쪽의 피연산자에 오른쪽의 피연산자를 나머지 연산 후 대입|num %= 2|
|`&=`|왼쪽의 피연산자와 오른쪽의 피연산자를 AND 연산 후 대입|num &= 2|
|`l=`|왼쪽의 피연산자와 오른쪽의 피연산자를 OR 연산 후 대입|num ㅣ= 2|
|`^=`|왼쪽의 피연산자와 오른쪽의 피연산자를 NOR 연산 후 대입|num ^= 2|
|`<<=`|왼쪽의 피연산자를 오른쪽의 값만큼 좌측 시프트 연산 후 대입|num <<= 2|
|`>>=`|왼쪽의 피연산자와 오른쪽의 값만큼 우측 시프트 연산 후 대입|num >>= 2|

예) `num += 2`는 `num = num + 2`와 같습니다.

## 비트 연산자

비트 연산자는 **숫자를 비트 단위로 연산하는 연산자**입니다. 두 수를 비교하는 비트 논리 연산자와 비트를 이동시키는 비트 이동 연산자가 있습니다.

### 비트 논리 연산자

|연산자|이름|설명|
|---|---|---|
|`&`|AND 연산자|두 피연산자의 비트를 하나씩 비교 후 둘 다 1이라면 1, 하나라도 0이라면 0|
|`l`|OR 연산자|두 피연산자의 비트를 하나씩 비교 후 하나라도 1이라면 1, 아니면 0|
|`^`|NOR 연산자|두 피연산자의 비트를 하나씩 비교 후 값이 서로 다르면 1, 아니면 0|
|`~`|NOT 연산자|피연산자의 비트를 모두 반대로 바꿈|

예제를 보며 알아봅시다.

#### 논리곱(AND) 연산

~~~java
int and = 1 & 2;
~~~

`0000 0001` (1)  
`0000 0010` (2)  
각 비트를 비교하면 각 자리의 비트가 모두 1인 경우는 없기 때문에 `0000 0000`이 됩니다. 따라서 값은 0이 됩니다.

#### 논리합(OR) 연산

~~~java
int or = 1 | 2;
~~~

`0000 0001` (1)  
`0000 0010` (2)  
각 비트를 오른쪽 부터 비교해보면 1인 경우는 1일때 첫 번째와 2일 때 2번째 입니다. 따라서 `0000 0011`이 되고 값은 3이 됩니다.

#### 부정논리합(NOR) 연산

`0000 0001` (1)  
`0000 0010` (2)  
각 비트를 오른쪽 부터 비교해보면 서로 다른 값은 첫 번째와 두 번째 자리 입니다. 따라서 `0000 0011`이 되고 값은 3이 됩니다.

### 비트 반전 연산자

비트 반전 연산자는 피연산자가 한 개입니다. 2를 반전 하게 되면 다음과 같습니다.

`0000 0010`  
-> `1111 1101`  

따라서 결과가 253이 나올 것 같지만 실제 값을 확인해보면 -3이 나옵니다. 왜 이렇게 나오는 것일까요? 사실 위에서 2진수를 표현한 것은 1 byte만으로 표현한 것인데 자바의 int는 총 4 byte로 이루어 져있기 때문에 실제로는 2의 2진수 표현은 다음과 같습니다.

`0000 0000 0000 0000 0000 0000 0000 0010`

따라서 반전 연산을 하게 되면

`1111 1111 1111 1111 1111 1111 1111 1101`

이렇게 비트가 만들어 지는데, 맨 왼쪽의 자리는 부호 비트입니다. 0이면 양수 1이면 음수가 됩니다. 음수는 양수와는 반대로 가장 낮은 자리부터 비트가 0으로 변경되면서 값이 줄어들게 됩니다.

`1111 1111 1111 1111 1111 1111 1111 1111` (-1)  
`1111 1111 1111 1111 1111 1111 1111 1110` (-2)  
`1111 1111 1111 1111 1111 1111 1111 1101` (-3)  

여기서 보면 -3의 값이 2를 반전시켜 얻은 값과 동일합니다. 따라서 값은 -3입니다.

### 비트 이동 연산자 (Shift 연산자)

비트 이동 연산자는 말 그대로 **비트를 특정 수만큼 옆으로 이동시키는 연산자**입니다. `<<` `>>`와 자바에만 존재하는 `>>>` 이렇게 총 세 가지가 존재합니다. 앞의 두 연산자는 이동되어 빈 비트를 바로 원래 있던 비트로 채우지만, 마지막 `>>>`는 이동되어 빈 비트를 0으로 채웁니다. 즉, `>>>`는 늘 양수를 반환합니다.

|연산자|설명|예|
|--|--|--|
|`>>`|a의 비트를 b만큼 오른쪽으로 이동 시킨 후 빈 공간을 부호 비트의 값으로 채움|a >> b|
|`<<`|a의 비트를 b만큼 왼쪽으로 이동 시킨 후 빈 공간을 0으로 채움 |a << b|
|`>>>`|a의 비트를 b만큼 오른쪽으로 이동 시킨 후 빈 공간을 0으로 채움|a >>> b|

~~~java
int a = 8 >> 3; //1
int b = 1 << 3; //8
int c = -100 >> 2; //8
int d = -100 >>> 2; //1073741799
~~~

~~~
a
    |00000000000000000000000000001000|-->    //오른쪽으로 3칸 이동
    |000 00000000000000000000000000001|000   //앞의 빈 공간은 부호 비트인 0으로 채워지고 뒤의 000은 버려짐
결과: 1

b
  <--|00000000000000000000000000000001|      //왼쪽으로 3칸 이동
  000|00000000000000000000000000001 000|     //뒤의 빈 공간은 부호 비트인 0으로 채워지고 앞의 000은 버려짐
결과: 8

c
    |11111111111111111111111110011100|->     //오른쪽으로 2칸 이동
    |11 111111111111111111111111100111|00    //앞의 빈 공간은 부호 비트인 1로 채워지고 뒤의 00은 버려짐
결과: -25

d
    |11111111111111111111111110011100|->     //오른쪽으로 2칸 이동
    |00 111111111111111111111111100111|00    //앞의 빈 공간은 0으로 채워지고 뒤의 00은 버려짐
결과: 1073741799
~~~

`a`, `b`, `c`는 모두 값에 해당하는 비트만 이동되고 부호 비트는 변경되지 않기 때문에 부호가 변경되지 않습니다. 하지만 `d`는 부호 비트가 1이어도 무조건 0으로 채워지기 때문에 부호가 변경됩니다.

## 관계 연산자

관계 연산자는 **두 값를 비교하여 결과 값으로 참이나 거짓을 반환하는 연산자**입니다.

|연산자|설명|예|
|---|---|--|
|`==`|두 수가 같음|1 == 1|
|`!=`|두 수가 다름|1 != 2|
|`>`|왼쪽의 수가 오른쪽의 수보다 큼|2 > 1|
|`<`|왼쪽의 수가 오른쪽의 수보다 작음|2 < 3|
|`>=`|왼쪽의 수가 오른쪽의 수보다 크거나 같음|2 >= 2|
|`<=`|왼쪽의 수가 오른쪽의 수보다 작거나 같음|2 <= 2|

표의 예제는 결과가 모두 참이기 때문에 `true`를 반환합니다. 하지만 1 > 2 라는 식은 거짓이므로 `false`를 반환합니다.

## 논리 연산자

논리 연산자는 두 개의 논리 조건을 논리합(OR) 연산, 논리곱(AND) 연산, 부정 논리합(NOR)연산을 하거나 하나 이상의 조건의 논리 결과를 반전시킬 반전 연산자를 사용할 수 있습니다. C, C++는 숫자로도 논리 연산이 가능하지만 자바는 `boolean` 타입의 연산만 가능합니다. 비트 연산을 공부할 때도 배웠던 것이지만 일반적인 논리 연산에서는 기호가 조금 다릅니다.

|연산자|설명|예|
|---|---|---|
|`&&`|두 개의 조건이 모두 참이면 true, 하나라도 거짓이라면 false를 반환 |a == b && c == d|
|`ll`|두 개의 조건 중 하나라도 참이면 true, 모두 거짓이라면 false를 반환|a == b ll c == d|
|`^`|두 개의 조건이 서로 다르다면 true, 같다면 false를 반환|a == b ^ c == d|
|`!`|하나의 논리 결과를 반전시킴|!(a == b)|

## instanceof 연산자

프로그래밍시 동적으로 인스턴스가 생성될 때, 해당 타입이 무엇인지 알아야 후처리를 할 수 있습니다. 이 때 `instanceof` 연산자를 사용할 수 있습니다. `instanceof` 연산자는 **좌측에 있는 인스턴스가 우측에 있는 클래스의 타입인지 확인하는 연산자**입니다. 동일 타입이나 상위 타입을 상속 받았는지 또는 인터페이스를 상속받았는 지 확인할 수 있습니다. 쉽게 말해 앞에 있는 인스턴스가 뒤에 있는 클래스나 인터페이스 타입 변수에 할당될 수 있는지를 알 수 있습니다.

~~~java
class A {}

class B extends A {}

//...
A a = new A();
System.out.println(a instanceof A); //true
System.out.println(a instanceof B); //false

B b = new B();
System.out.println(b instanceof A); //true
System.out.println(b instanceof B); //true

A a2 = new B();
System.out.println(a2 instanceof A); //true
System.out.println(a2 instanceof B); //true
~~~

예제를 살펴보며 하나씩 결과를 확인해보겠습니다.

* `a`
  * `a`는 `A` 타입 인스턴스를 담고 있기 때문에 `A` 타입에는 할당 할 수 있지만 `B`타입은 자식 타입이라 할당할 수 없습니다. 따라서 `true`, `false` 순으로 출력이 됩니다.
* `b`
  * `b`는 `A`를 상속받은 B타입의 인스턴스를 담고 있기 때문에 `A`, `B` 모두 할당이 가능합니다. 따라서 모두 `true`가 출력 됩니다.
* `a2`
  * `a2`는 `B`의 인스턴스가 담겨 있지만 타입이 A인 변수에 담겨져 있습니다. 그래서 `a2 instanceof B` 연산을 하게 되면 `false`가 출력될 것 같지만 `true`가 출력됩니다. 값이 담긴 변수의 타입을 확인하는 것이 아닌 실제 힙 영역에 저장된 인스턴스의 타입을 확인하는 것이기 때문입니다. 실제로 `a2`의 클래스를 출력해보면 다음과 같이 출력됩니다.

~~~java
System.out.println(a2.getClass());
~~~

~~~
class com.test.B
~~~

이는 인터페이스를 구현한 경우에도 마찬가지입니다.

~~~java
interface A {}

class B implements A {}

//...
A a = new B();
System.out.println(a instanceof A); //true
System.out.println(a instanceof B); //true
System.out.println(a.getClass()); //class com.test.B

B b = new B();
System.out.println(b instanceof A); //true
System.out.println(b instanceof B); //true
~~~

## 화살표(`->`) 연산자

화살표 연산자는 C/C++과 자바에서 사용 방법이 매우 다릅니다. C/C++에서는 포인터에 접근하여 그 안의 변수에 접근하기 위한 연산자이고, 자바에서는 Java 8에 도입된 **람다식에 사용되는 연산자**입니다. 람다식은 다음에 자세히 공부할 것이므로 사용 방법만 간단히 알아보고 넘어가도록 하겠습니다.

~~~java
Runnable runnable = () -> System.out.println("Hello");
~~~

## 3항 연산자

3항 연산자는 **조건문과 조건문의 결과에 따라 반환할 값으로 이루어진 연산자**입니다. 분기문과 거의 동일하지만 값이 무조건 반환되어야 합니다. 형태는 다음과 같습니다.

~~~
(조건문) ? (참일 때 결과 값) : (거짓일 때 결과 값)
~~~

~~~java
int num1 = 1;
int num2 = 2;

String result = num1 > num2 ? "num1 is bigger than num2" : "num2 is bigger than num1";

System.out.print(result); //num2 is bigger than num1
~~~

3항 연산자는 값을 반환하기 때문에 중첩해서 사용할 수 있습니다. 다만 중첩이 많아 질 수록 가독성이 떨어지기 때문에 분기문으로 바꿔서 사용하는 것이 좋을 수도 있습니다.

~~~java
boolean isSam = false;
boolean isMin = false;
boolean isYun = true;

//삼항 연산자
String name = isSam ? "sam" : isMin ? "min" : isYun ? "yun" : "nothing";

//if문
String name;
if (isSam) {
    name = "sam";
} else if (isMin) {
    name = "min";
} else if (isYun) {
    name = "yun";
} else {
    name = "nothing";
}
~~~

3항 연산자가 한 줄로 작성할 수 있다는 점에서 길이는 짧아지지만 가독성 측면에서 매우 안 좋아 보입니다. 위의 예제는 간단한 수준이라 덜하겠지만 조건문이 조금만 더 복잡해진다면 분기문을 사용하는 것이 길이는 길어지지만 가독성 측면에서 훨씬 나아보입니다.

## 연산자 우선 순위

각각의 연산자는 연산 순서가 있습니다. 만약 아래와 같은 식이 있다면 연산 결과는 어떻게 될까요?

~~~java
int a = 1;
int b = 2;
int c = 3;
int d = 4;

boolean result = ++a >= b || c > d;

System.out.print(result);
~~~

먼저 우선 순위 표를 본 후 결과를 예측해봅시다.

|우선 순위|연산자|종류|방향|
|---|---|---|---|
|1|1차식, 후위 증감 연산자|[], (), ., ->, a++, a--|<-|
|2|전위 증감연산자, 단항 연산자|++a, --a, +a, -a, ~a, !a|->|
|3|산술 연산자| *, /, %, +, -|->|
|4|비트 이동 연산자|<<, >>, >>>|->|
|5|관계 연산자, instanceof| <, > <=, >=, ==, !=, instanceof|->|
|6|비트 연산자|&, ^, ㅣ|->|
|7|논리 연산자|&&, ㅣㅣ|->|
|8|삼항 연산자|?:|->|
|9|대입 연산자|=, +=, -=,*=, /=, &=, ^=, ㅣ=, <<=, >>=, >>>=|<-|

연산은 다음과 같이 수행됩니다.

1. `a`에 붙은 전위 증감 연산자가 우선 순위가 높으니 `a`는 1이 증가해서 2가 됩니다.
2. `a`와 `b`의 값과 같아지게 되므로 2번째 우선순위인 관계 연산자로 인해 `++a >= b`는 `true`가 됩니다.
   - 결과: `true || c > d`
3. 논리연산자인 `||`가 있지만 우선 순위가 높은 관계 연산자가 있으니 `c > d`는 `false`가 됩니다.
   - 결과: `true || false`
4. 논리연산 `||`을 수행하게 되면 `true`와 `false`를 OR 연산하는 것이므로 결과는 `true`가 됩니다.
   - 결과: `true`

만약 전위 증감 연산자가 관계 연산자보다 우선순위가 낮다면 2번의 결과는 `false`가 되고 최종 결과는 `false`가 되겠지요? 따라서 우선순위를 숙지하고 논리식을 작성하는 것은 매우 중요합니다. 또한 이 처럼 연산자의 우선 순위 때문에 식이 길어지게 가독성이 매우 떨어지게 되므로, 여러 값을 연산하게 된다면 우선순위가 있더라도 괄호로 구분을 하여 작성하는 것이 좋을 것입니다.

~~~java
boolean result = (++a >= b) || (c > d);
~~~

## switch (Java 13)

자바 13부터(12에서는 커맨드 옵션에 `--enable-preview`를 붙여야함) `switch`연산자가 추가 되었습니다. 기존의 `switch`문과 다르게 변수에 할당이 가능한 연산자입니다.

~~~java
String str = "one";
int num = switch (str) {
    case "one": yield 1;
    case "two": yield 2;
    case "three": yield 3;
    case "four": yield 4;
    default: throw new RuntimeException();
};

System.out.print(num); //1
~~~

`case` 문 끝에 `yield`라는 키워드를 사용하여 값을 반환하여 사용하면 됩니다. 값을 블록단위로 반환 할 수 있게 된 것입니다. 다만 **변수에 할당을 해야하기 때문에 모든 케이스는 값을 반환해야 합니다.** `yield` 키워드를 통해 반환하지 않고 화살표 연산자를 사용하여 값을 바로 반환할 수도 있습니다.

~~~java
String str = "one";
int num = switch (str) {
    case "one" -> 1;
    case "two" -> 2;
    case "three" -> 3;
    case "four" -> 4;
    default -> throw new RuntimeException();
};

System.out.print(num); //1
~~~

또한 var를 사용하여 반환되는 값의 타입을 다양하게 할 수도 있습니다.

~~~java
String str = "one";

var num = switch (str) {
    case "one": yield "하나";
    case "two": yield 2;
    case "three": yield true;
    case "four": yield 4;
    default: throw new RuntimeException();
};

var num2 = switch (str) {
    case "one" -> 1;
    case "two" -> "둘";
    case "three" -> 3;
    case "four" -> true;
    default -> throw new RuntimeException();
};
~~~

동적으로 타입을 받는 것처럼 보이지만 `num2`에 해당하는 `switch`를 디컴파일한 코드를 보면 다음과 같습니다.

~~~java
String str = "one";

//...

byte var4 = -1;
switch(str.hashCode()) {
case 110182:
    if (str.equals("one")) {
        var4 = 0;
    }
    break;
case 115276:
    if (str.equals("two")) {
        var4 = 1;
    }
    break;
case 3149094:
    if (str.equals("four")) {
        var4 = 3;
    }
    break;
case 110339486:
    if (str.equals("three")) {
        var4 = 2;
    }
}

Object var10000;
switch(var4) {
case 0:
    var10000 = 1;
    break;
case 1:
    var10000 = "둘";
    break;
case 2:
    var10000 = 3;
    break;
case 3:
    var10000 = true;
    break;
default:
    throw new RuntimeException();
}

Serializable num2 = var10000;
System.out.println(num2);
}
~~~

컴파일시 반환 타입 들이 공통으로 상속받은 상위 타입 중 가장 하위 클래스를 따릅니다. 예를 들어 모든 클래스가 `Serializable` 인터페이스를 상속 받았다면 모든 클래스의 공통 조상인 `Object` 클래스가 아닌 `Serializable` 타입으로 값을 받는다는 뜻입니다. 만약 하나의 반환 값이라도 공통 상속 클래스가 없다면 `Object` 타입으로 반환 값을 받게 됩니다. 만약 상속 받은 타입이 2개 이상이 일치하는 경우 두 인터페이스의 함수를 모두 쓴다면 어떻게 될까요? 다음의 예제 코드를 보면서 확인해 보겠습니다.

~~~java
class NewInteger extends Number implements Comparable<NewInteger>, Serializable {...}
class NewDouble extends Number implements Comparable<NewDouble>, Serializable {...}

//...
String str = "two";
var num2 = switch (str) {
    case "one" -> new NewInteger("1");
    case "two" -> new NewDouble("1.0");
    default -> throw new RuntimeException();
};

System.out.println(num2.compareTo(new NewInteger("0")));
System.out.println(num2.byteValue());
~~~

다음과 같이 `Number`, `Comparable` 인터페이스 두 개의 인터페이스를 구현한 `NewInteger`, `NewDouble`이라는 클래스가 있다고 생각해봅시다. 이렇게 되면 두 인터페이스의 함수를 모두 사용할 수 있게됩니다. 어떻게 사용할 수 있는지는 디컴파일한 class 파일을 보겠습니다.

~~~java
//...

Object var10000;
switch(var4) {
case 0:
    var10000 = new NewInteger("1");
    break;
case 1:
    var10000 = new NewDouble("1.0");
    break;
default:
    throw new RuntimeException();
}

Number num2 = var10000;
System.out.println(((Number)num2).byteValue());
System.out.println(((Comparable)num2).compareTo(new NewInteger("0")));
~~~

방법은 간단했습니다. 하나의 타입으로 받은 후 함수를 쓸 때마다 해당 함수가 있는 인터페이스(혹은 클래스)로 강제 형변환을 하게 됩니다. 하지만 이 경우 첫 번째로 출력한 `byteValue` 메서드는 문제가 없지만 `compareTo` 메서드의 경우 제네릭 타입의 불일치로 에러가 발생하게 됩니다.
