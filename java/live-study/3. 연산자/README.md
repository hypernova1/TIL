# 연산자

연산이란 프로그래밍에서 데이터를 처리하고 결과를 산출하는 것을 말합니다. 이때 사용되는 기호가 바로 연산자입니다. 그리고 연산의 대상이 되는 것이 바로 피 연산자입니다.

~~~
1 + 2
~~~

위와 같은 식이 있다고 할 때 `+`는 연산을 하는 연산자, 1과 2는 연산의 대상인 피연산자입니다.  

프로래밍에서는 일반적인 수학적 연산 이외에도 다양한 연산이 존재합니다. 기본적인 산술 연산자를 시작으로 하나씩 알아보도록 합시다.

## 산술 연산자

### 일반적인 산술 연산자

산술 연산자란 우리가 직관적으로 알고 있는 수학적 연산을 행하는 연산자입니다. 덧셈, 뺄셈, 곱셈, 나눗셈 그리고 나머지 연산(mod)이 있습니다.

~~~java
int sum = 1 + 2; //덧셈
int sub = 4 - 2; //뺄셈
int mul = 5 * 3; //곱셈
int div = 5 / 2; //나눗셈
int mod = 7 % 5; //나머지 연산(mod)
~~~

우리가 일상적으로 사용하는 덧셈, 뺄셈, 곱셈, 나눗셈의 경우는 일반적인 상식대로 사용하면 됩니다. 하지만 나머지 연산은 `%` 연산자를 사용하며 앞에 있는 숫자를 뒤에 있는 숫자로 나눈 뒤, 나머지를 반환합니다. 위의 니머지 연산에서 결과 값은 2가 됩니다. 하지만 주의할 점이 있습니다. 리터럴로 값을 연산하면 int형으로 반환이 된다는 것입니다. 따라서 위의 나눗셈과 같이 나머지가 필요한 경우에는 하나의 값을 double 또는 float으로 변환을 시킨 후 연산을 해야합니다. 다음의 예제를 통해 확인해 봅시다.

~~~java
double result = 2 / 4;
System.out.print(result); //0
~~~

결과 값을 double로 받았으니 당연히 0.5가 들어갈 것 같습니다. 하지만 결과 값을 확인해보면 0이 나오게 됩니다. 연산시 기본적으로 int를 사용하기 때문인데요. int는 소수점을 사용할 수 없는 타입이기 때문에 소숫점 이하는 버려지게 됩니다. 따라서 다음과 같이 변경하여 제대로된 결과 값을 얻을 수 있습니다.

~~~java
double result = (double) 2 / 4;
//or
double result = 2 / (double) 4;

System.out.prin(result); //0.5
~~~

2번째 과제에서 학습했듯이 타입 프로모션 때문입니다. 큰 타입과 작은 타입을 연산을 했을때 결과의 타입은 큰 타입으로 나오게 됩니다.

### 복합 대입 연산자

복합 대입 연산자는 변수와 값을 산술 연산하거나 논리 연산을 하는 연산자입니다. 연산자 뒤에 대입 연산자(`=`)를 붙여 사용하면 됩니다. 왼쪽의 피연산자를 오른쪽의 피연산자를 연산한 후 다시 대입합니다.

|연산자|설명|예|
|--|--|--|
|`+=`|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후 대입|num += 2|
|`-=`|왼쪽의 피연산자에 오른쪽의 피연산자를 뺀 후 대입|num -= 2|
|`*=`|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후 대입|num *= 2|
|`/=`|왼쪽의 피연산자에 오른쪽의 피연산자를 나눈 후 대입|num /= 2|
|`%=`|왼쪽의 피연산자에 오른쪽의 피연산자를 나머지 연산 후 대입|num %= 2|
|`&=`|왼쪽의 피연산자와 오른쪽의 피연산자를 AND 연산 후 대입|num &= 2|
|`|=`|왼쪽의 피연산자와 오른쪽의 피연산자를 OR 연산 후 대입|num ㅣ= 2|
|`^=`|왼쪽의 피연산자와 오른쪽의 피연산자를 NOR 연산 후 대입|num ^= 2|
|`<<=`|왼쪽의 피연산자를 오른쪽의 값만큼 좌측 시프트 연산 후 대입|num <<= 2|
|`>>=`|왼쪽의 피연산자와 오른쪽의 값만큼 우측 시프트 연산 후 대입|num >>= 2|

### 증감 연산자

프로그래밍 언어에서는 일반적인 산술 연산자 이외에 **증감 연산자**라는 것도 존재합니다. 증감 연산자는 피연산자 앞뒤에 붙어서 피연산자를 1 증가 시키거나 감소시킵니다. 연산자가 앞에 붙으면 **전위 증감 연산자**, 뒤에 붙으면 **후위 증감 연산자**라고 합니다.

~~~java
int num = 0;

int preSum = ++num; //전위 증가 연산자
int postSum = num++;//후위 증가 연산자

int preSub = --num; //전위 감소 연산자
int postSub = num--;//후위 감소 연산자
~~~

전위/후위 증감 연산자는 모두 값을 1 증가 시키거나 감소시킨다고 했습니다. 그렇다면 어떤 차이가 있길래 구분하여 사용하는 것일까요? 바로 증감을 언제 시키느냐에 따라 다르게 사용됩니다. 전위 증감 연산자는 해당 피연산자의 값을 증감 시킨 후 변수에 할당하도록 하고, 후위 증감 연산자는 할당 후 값을 증감시킵니다.

~~~java
//전위
int num = 0;
int preSum = ++num;
System.out.print(preSum); //1

//후위
int num = 0;
int postSum = num++;
System.out.print(postSum); //0
~~~

## 비트 연산자

비트 연산자는 숫자를 비트 단위로 연산하는 연산자입니다. 두 수를 비교하는 비트 논리 연산자와 비트를 이동시키는 비트 이동 연산자가 있습니다.

### 비트 논리 연산자

|연산자|이름|설명|
|---|---|---|
|`&`|AND 연산자|두 피연산자의 비트를 하나씩 비교 후 둘 다 1이라면 1, 하나라도 0이라면 0|
|`|`|OR 연산자|두 피연산자의 비트를 하나씩 비교 후 하나라도 1이라면 1, 아니면 0|
|`^`|NOR 연산자|두 피연산자의 비트를 하나씩 비교 후 값이 서로 다르면 1, 아니면 0|
|`~`|NOT 연산자|피연산자의 비트를 모두 반대로 바꿈|

예제를 보며 알아봅시다.

#### AND 연산

~~~java
int and = 1 & 2;
~~~

`0000 0001` (1)  
`0000 0010` (2)  
각 비트를 비교하면 각 자리의 비트가 모두 1인 경우는 없기 때문에 `0000 0000`이 됩니다. 따라서 값은 0이 됩니다.

#### OR 연산

~~~java
int or = 1 | 2;
~~~

`0000 0001` (1)  
`0000 0010` (2)  
각 비트를 오른쪽 부터 비교해보면 1인 경우는 1일때 첫 번째와 2일 때 2번째 입니다. 따라서 `0000 0011`이 되고 값은 3이 됩니다.

#### NOR 연산

`0000 0001` (1)  
`0000 0010` (2)  
각 비트를 오른쪽 부터 비교해보면 서로 다른 값은 첫 번째와 두 번째 자리 입니다. 따라서 `0000 0011`이 되고 값은 3이 됩니다.

### 비트 반전 연산자

비트 반전 연산자는 피연산자가 한 개입니다. 2를 반전 하게 되면 다음과 같습니다.

`0000 0010`  
-> `1111 1101`  

따라서 결과가 253이 나올 것 같지만 실제 값을 확인해보면 -3이 나옵니다. 왜 이렇게 나오는 것일까요? 사실 위에서 2진수를 표현한 것은 1 byte만으로 표현한 것인데 자바의 int는 총 4 byte로 이루어 져있기 때문에 실제로는 2의 2진수 표현은 다음과 같습니다.

`0000 0000 0000 0000 0000 0000 0000 0010`

따라서 반전 연산을 하게 되면

`1111 1111 1111 1111 1111 1111 1111 1101`

이렇게 비트가 만들어 지는데, 맨 왼쪽의 자리는 부호 비트입니다. 0이면 양수 1이면 음수가 됩니다. 음수는 양수와는 반대로 가장 낮은 자리부터 비트가 0으로 변경되면서 값이 줄어들게 됩니다.

`1111 1111 1111 1111 1111 1111 1111 1111` (-1)  
`1111 1111 1111 1111 1111 1111 1111 1110` (-2)  
`1111 1111 1111 1111 1111 1111 1111 1101` (-3)  

여기서 보면 -3의 값이 2를 반전시켜 얻은 값과 동일합니다. 따라서 값은 -3입니다.

### 비트 이동 연산자 (Shift 연산자)

## 관계 연산자

## 논리 연산자

## instanceof

## assignment(=) operator

## 화살표(->) 연산자

## 3항 연산자

## 연산자 우선 순위

## Java 13. switch 연산자