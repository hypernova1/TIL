# JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가.

## JVM이란
JVM(*Java Virtual Machine*)이란 단어의 뜻 그대로 자바를 실행하는 가상 머신입니다. 네이티브 코드를 실행하는 것이 아닌 바이트 코드를 JVM에 실행하도록 함으로써 개발자가 운영체제를 신경쓰지 않고 코드를 작성할 수 있도록 합니다. 뿐만 아니라 내장 되어있는 가비지 컬렉터가 특정 시점에 불필요하다 판단되는 자원을 알아서 해제해주기 때문에, 개발자가 자원 전체를 관리할 필요가 없어 코드 작성시 부담을 줄여줍니다. 하지만 JVM만 믿고 무분별하게 코드를 작성하게 되면 메모리 누수를 발생시킬 수 있기 때문에 자바 개발자라면 JVM에 대해 제대로 이해하고 코드를 작성할 수 있어야 할 것입니다. JVM은 원래 자바를 실행하기 위한 목적으로 만들어졌지만 현재는 코틀린, 스칼라 등과 같은 언어들도 지원하고 있습니다.

<hr>

## JVM의 구성요소

JVM는 클래스로더, 런타임 메모리 영역, 실행 엔진 등으로 이루어져 있습니다.

### 1. 클래스로더

`java`파일이 컴파일러에 의해 `class`파일로 변환이 되면 JVM이 읽을 수 있는 상태가 됩니다. 클래스로더는 `class` 파일을 읽어 메모리에 적재하고 링크하며 초기화하는 역할을 담당합니다. 클래스로더는 다음과 같이 세 가지가 존재합니다.

* Bootstrap ClassLoader: 최상위 클래스로더입니다. 모든 클래스 로더의 부모이며 네이티브 코드로 작성이 되어있습니다. $JAVA_HOME/jre/lib/rt.jar 에 있는 클래스 들을 로딩합니다.
* Extention(Platform) ClassLoader: 부트스트랩 클래스로더의 하위 클래스로더입니다. $JAVA_HOME/jre/lib/ext 경로에 있는 클래스 들을 로딩합니다.
* Application(System) ClassLoader: Extention 클래스로더의 하위 클래스로더입니다. 개발자가 작성한 클래스 들을 로딩합니다.

각 클래스 로더는 계층적으로 존재하며 하위 클래스로더에서 클래스를 찾지 못하면 상위 클래스로 위임을 하고 최상위 부모인 부트스트랩 클래스로더에도 없다면 `ClassNotFoundException`을 반환합니다.

### 2. 런타임 메모리 영역

런타임 메모리 영역은 JVM의 프로세스를 수행하기 위해 운영체제에서 할당 받은 메모리 공간입니다. 메서드 영역, 힙 영역, 스택 영역, PC 레지스터 영역, 네이티브 메소드 스택 영역이 존재합니다.

#### 메소드 영역

클래스 영역이라고도 하며 JVM 실행시 생성됩니다. 메타 데이터 및 런타임 상수풀, 필드 및 메소드와 같은 클래스의 정보를 저장합니다. 모든 스레드에 공유되는 영역입니다.

#### 힙 영역

인스턴스가 저장되는 공간입니다. new 키워드를 통해 동적으로 생성된 자원 (인스턴스 및 배열)을 관리합니다. 또한 영역은 가비지 컬렉션의 대상이 됩니다. 모든 스레드 영역에서 공유되는 영역입니다.

#### 스택 영역

지역 변수 및 메서드의 파라미터를 저정하는 공간입니다. 변수에 원시타입이 저장될 때는 값 자체가 저장되지만 인스턴스나 배열의 경우에는 힙영역의 주소값이 저장됩니다. 각 스레드마다 생성이 되며 메서드가 호출될 때마다 새로운 프레임이 생성되고 완료되면 삭제됩니다. 

#### PC 레지스터 영역

JVM 명령의 주소를 저장하는 공간입니다. 각 스레드 마다 생성됩니다.

### 3. 실행 엔진

실행 엔진은 클래스로더가 읽어 들인 바이트 코드를 명령어 단위로 실행합니다. 인터프리터 방식과, JIT 컴파일러 방식으로 나뉩니다. 이 부분은 아래의 [JIT 컴파일러란 무엇이며 어떻게 동작하는가](#JIT-컴파일러란-무엇이며-어떻게-동작하는가)설명되어 있습니다.

### 4. 가비지 컬렉터

자바는 개발자가 직접 메모리를 해제할 수 없습니다. 개발자에게 판단을 맡기는 대신 가비지 컬렉터가 알고리즘을 통해 더 이상 인스턴스가 사용되지 않는다고 판단될 때 즉시 인스턴스를 수거해가는 방식으로 되어있습니다. `System.gc()`라는 함수를 통해 가비지 컬렉터를 직접 호출할 순 있지만 `stop-the-world` 상태가 되어 GC 스레드를 제외한 나머지 스레드가 동작을 멈추기 때문에 절대로 사용해서는 안됩니다. 가비지 컬렉터는 자체만으로도 설명할 내용이 많아 추후 따로 정리할 예정입니다.

### 네이티브 메서드 스택

자바로 직접 구현하기에는 속도가 너무 느릴 것이라 판단 될 때 C나 C++ 등과 같은 언어로 메서드를 작성할 수 있습니다. 이에 대한 정보가 저장되는 영역입니다. 각 스레드마다 생성됩니다.

<hr>

## 컴파일 및 실행하기
일단 컴파일을 하기 위해서는 JDK라는 도구를 설치해야 합니다. 여기서는 이미 JDK가 설치되었다고 가정하고 설명을 하겠습니다(Open JDK는 [이곳](https://github.com/ojdkbuild/ojdkbuild)에서 다운 받을 수 있습니다).  
다운을 받게 되면 bin이라는 폴더 안에 javac라는 파일이 보일 것입니다. 이 것이 바로 자바 컴파일러이며 java 파일을 class 파일로 변환해 주는 도구입니다. 먼저 java 파일을 작성해 보겠습니다. 간단하게 텍스트 파일을 열어 작성해 봅시다.

filename: MyClass.java
~~~java
public class MyClass {
    public static void main(String[] args) {
        System.out.print("Hello World!");
    }
}
~~~

java 파일을 작성한 후에는 파일이 있는 경로로 들어간 후 `javac`를 사용하여 컴파일 해 봅시다.

~~~
$ javac MyClass
~~~

명령어를 입력하게 되면 같은 폴더에 `MyClass.class`라는 파일이 생성되었을 것입니다. 이 파일이 바로 바이트 코드가 저장되어 있는 class 파일입니다. 이제 컴파일된 class 파일을 `java` 명령어를 통해 실행해 봅시다.

~~~
$ java MyClass

Hello World!
~~~

<hr>

## 바이트 코드란 무엇인가

바이트 코드란 사람이 이해할 수 있도록 작성된 `java` 파일을 JVM이 이해할 수 있도록 컴파일한 코드입니다. `class`파일 내부에 작성되어 있으며 `javap`를 통해 개발자가 알아볼 수 있도록 변환할 수 있습니다.

~~~
$ javap MyClass

Compiled from "MyClass.java"
public class MyClass {
  public MyClass();
  public static void main(java.lang.String[]);
}
~~~

바이트 코드는 네이티브 코드가 아니기 때문에 하드웨어에서 바로 실행할 수 없어서 C나 C++과 같이 기계어로 컴파일 되어 실행되는 언어에 비해 속도가 느립니다. 하지만 후술할 JIT 컴파일러를 통해 어느정도 속도를 보장할 수 있게 되었습니다.

<hr>

## JIT 컴파일러란 무엇이며 어떻게 동작하는가

바이트 코드는 운영체제에서 직접 실행되는 것이 아니라 JVM을 통해 해석된 후 실행되기 때문에 인터프리터 방식이라고 할 수 있습니다. 인터프리터 방식은 코드를 그때그때 한 줄씩 읽어서 해석하고 실행하게 되는데, 똑같은 코드를 매번 읽고 해석 하는 것은 매우 불필요한 일입니다. 그래서 JIT(Just-In-Time) 컴파일러가 도입되었습니다. JIT 컴파일러는 자주 실행되는 영역을 파악한 후 해당 코드만을 컴파일하고 최적화하여 기계어로 만든 다음, 이 후에 실행시 기계어로 바로 실행될 수 있도록 합니다. 짧은 코드의 경우 한 번만 실행하면 되기 때문에 인터프리터 방식이 JIT 컴파일 방식 보다 빠르겠지만 애플리케이션에서는 반복적으로 코드를 실행하는 경우가 대부분이기 때문에 JIT 컴파일처럼 미리 기계어로 컴파일을 해놓고 실행하는 것이 효율적입니다.

<hr>

## JDK와 JRE의 차이

**JDK**는 *Java Development Kit*의 약자로 개발에 필요한 도구 모음입니다. `javac`(컴파일러), `jdb`(디버거), `javap`(역어셈블러) 등 개발시에 필요한 유용한 프로그램 들이 포함되어있습니다. JDK는 오라클에서 제공하는 Oracle JDK와 Open JDK로 나뉘어져 있으며 Open JDK는 여러 벤더사(오라클, 아마존, 레드햇 등)에서 만들고 관리하지만 동일한 스펙을 구현하였기 때문에 각 JDK 마다의 기능 차이는 거의 없습니다. **JRE**는 *Java Runtime Enviroment*의 약자로 자바 실행에 필요한 환경을 제공해줍니다. JVM, 클래스 로더 등이 이에 해당합니다. JRE는 JDK에 포함되어 있습니다.

### 참고
https://m.blog.naver.com/2feelus/220738480797  
https://madplay.github.io/post/openjdk-vs-oracle-jdk  
https://engkimbs.tistory.com/606