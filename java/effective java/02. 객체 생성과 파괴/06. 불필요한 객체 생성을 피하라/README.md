# 불필요한 객체 생성을 피하라

똑같은 기능을 하는 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는 편이 나을 때가 있다. 특히 불변 객체는 언제든 재사용 가능하다. 다음의 예는 하지 말아야할 극단적인 예이다.

~~~java
String s = new String("hello");
~~~

위의 코드는 실행될 때마다 `String` 인스턴스를 새로 만든다. 생성자에 넘긴 "hello"라는 리터럴 값은 생성자로 만들어내려는 `String`과 기능적으로 완전히 같다. 또한 이 코드가 반복문이나 빈번히 호출되는 메서드 안에 포함되어 있다면 새로운 인스턴스가 불필요하게 많이 만들어질 수 있다.

~~~java
String s = "hello";
~~~

위의 코드의 경우에는 인스턴스를 매번 생성하는 대신 하나의 `String` 인스턴스를 사용한다. 위의 코드를 똑같이 사용하는 곳에서는 항상 같은 인스턴스를 사용함이 보장이 된다. (`String`은 리터럴로 생성시에 내부적으로 `intern` 메서드를 호출된다. 이 메서드는 기존의 인스턴스가 있는지 확인하고 없다면 새로운 인스턴스를 만들어 반환한다.)

## 객체를 불필요하게 많이 만들 필요가 없는 경우

`String`이나, `Boolean` 등 포인터가 아닌 값이 중요할 때는 똑같은 객체를 두 개 이상 만들 필요가 없다. 생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리를 사용하여 불필요한 객체 생성을 피할 수 있다. 생성자는 항상 인스턴스를 만들어 내지만 정적 팩터리 메서드는 필요에 따라 기존의 인스턴스를 반환하도록 프로그래머가 설정할 수 있기 때문이다. 예를 들어 `Boolean` 클래스의 경우 생성자 대신 `Boolean.valueOf(String)`을 사용하는 것이 그렇다. 생성자는 자바 9에서 deprecated 되었다.

~~~
Boolean a = new Boolean("true");
Boolean b = new Boolean("true");

Boolean c = Boolean.valueOf("true");
Boolean d = Boolean.valueOf("true");

System.out.println(a == b); //false;
System.out.println(c == d); //true;
~~~

## 생성 비용이 비싼 경우

생성 비용이 비싼 객체의 경우 캐싱해서 사용하는 것이 좋다. 하지만 어떤 객체가 비싼 객체인지 매변 명확히 알 수 없다. 예를 들어 문자열이 유효한 로마 숫자인지를 확인하는 메서드가 그렇다.

#### 기존 코드
~~~java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
~~~

`String.matches`는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다. **메서드 내부에서 `Pattern` 인스턴스가 생성된 후 한 번 쓰고 버려지기 때문에 바로 가비지 컬렉션의 대상이 되기 때문이다.** `Pattern`은 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)를 만들기 때문에 인스턴스 생성 비용이 높다.

성능을 개선하기 위해서는 불변인 `Pattern` 인스턴스를 클래스 초기화시 정적 필드로 생성하여 캐싱해두고 `isRomanNumeral` 메서드가 호출될 때마다 인스턴스를 재사용하면 된다.

#### 개선된 코드
~~~java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    public static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
~~~

이렇게 변경하게 되면 속도도 훨씬 빨라지고 코드 또한 명확해진다. 개선 전에는 `Pattern` 인스턴스의 존재 유무를 몰랐지만 `Pattern` 인스턴스를 static final 필드로 끄집어 내고 이름을 지어주어 코드의 의미가 명확해진다.

재사용시 덜 명확하거나 직관에 반대되는 경우도 있다. 어댑터(뷰)의 경우가 그러하다. 어댑터란 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체이다. 어댑터는 뒷단 객체만 관리하면 되기 때문에 뒷단 객체 하나당 어댑터 하나씩만 만들면 충분하다. 

`Map` 인터페이스의 `keySet` 메서드는 `Map` 객체 안의 키 전부를 담은 `Set` 뷰를 반환한다. `keySet`을 호출할 때마다 새로운 `Set` 인스턴스가 만들어 지리라 생각할 수 있지만 매번 같은 인스턴스를 반환한다. 

~~~java
public Set<K> keySet() {
    Set<K> ks = keySet;
    if (ks == null) {
        ks = new KeySet();
        keySet = ks;
    }
    return ks;
}
~~~

반환된 `Set` 인스턴스가 일반적으로 가변이더라도 반환된 인스턴스들은 기능적으로 모두 똑같다. 즉, 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 바뀐다. 모두가 똑같은 `Map` 인스턴스를 대변하기 때문이다. 따라서 `keySet`이 뷰 객체를 여러 개 만들어도 상관 없지만 불필요하다.

불필요한 객체를 만들어 내는 또 다른 예로는 오토박싱(auto boxing)을 들 수 있다. 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주지는 않는다. 의미상으론 같지만 성능상으론 다르다.

~~~java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }

    return sum;
}
~~~

위의 코드는 sum을 선언할 때 기본 타입이 아닌 박싱 타입으로 선언했기 때문에 반복문 안에서 더할 때 매 번 새로운 `Long` 인스턴스를 생성한다. 따라서 sum을 `long`으로 선언했을 때 보다 속도가 10배 정도 차이가 나는 현상이 발생한다. 따라서 **박싱 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 발생하지 않도록 주의해야한다.**

이번 아이템의 주제는 '객체 생성은 비싸니 피헤야한다.'가 아니다. 요즘의 JVM은 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않기 때문에 프로그램의 명확성이나, 간결성, 기능을 위해서 객체를 추가로 생성하는 것은 일반적으로 좋다.

반대로, 아주 무거운 객체가 아니라면 단순히 생성을 피하고자 직접 객체 풀을 생헝하지 말자. 데이터베이스를 접근하는 경우는 생성 비용이 워낙 비싸기 때문에 생성해서 재사용하는 편이 좋지만 일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리며, 성능을 떨어뜨린다. 요즘의 JVM은 최적화가 잘 되어 있어서, 가벼운 객체비용을 다룰 때는 직접만든 객체 풀보다 직접 생성하는 것이 훨씬 빠르다.