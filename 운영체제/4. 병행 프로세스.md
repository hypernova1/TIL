# 병행 프로세스

## 1. 병행 프로세스의 개념 

### I. 병행성(concurrency)

* **여러개의 프로세스 또는 쓰레드가 동시에 실행**되는 시스템의 특성

### II. CPU의 개수에 따른 병행 프로세스의 실행 형태

#### i. 하나의 CPU에서 인터리빙 형식으로 실행

#### ii. 여러개의 CPU에서 병렬 처리 형식으로 실행

#### iii. 메모리 구조에 따른 병행 프로세스의 실행 형태

##### 강결합 멀티 프로세서 시스템

* 공유 메모리 구조
  * 하나의 메모리를 여러 CPU가 공유해서 사용
  * 하나의 컴퓨터

* 약결합 멀티 프로세서 시스템
  * 분산 메모리 구조
    * CPU마다 메모리가 존재
    * 여러대의 컴퓨터
    * 네트워크로 통신하여 사용

### III. 병행성 문제

#### 병행 프로세스들이 상호작용 하는 경우 발생

* 공유 자원 점유 문제
* 동기화 문제
* 통신 문제

#### 상황에 따른 구분

##### i. 단일 프로세스 내의 병행성

* ~~~
  S1: a := x + y;
  S2: b := z + 1;
  S3: c := a + b;
  S4: write(c);
  ~~~

##### ii. 우선 순위 그래프

* 정점: 문장

* 방향 있는 간선: 우선 순위 관계

* DAG

* ~~~
  S1		S2
     ↘↙
      S3
      ↓
      S4

  ~~~

##### iii. Fork/Join 구조

* fork L: 2개의 병행 수행을 만듦(레이블 L위치 , fork 명령어 다음)

* ~~~
  S1
  ↓
  fork S3 ↴
  ↓	    S3
  S2
  
  ~~~

* ​	join n: 병행하는 n개의 흐름을 하나로 결합

* ~~~
  S4		S5
     ↘↙
     join 2
     	↓
     	S6
  ~~~

##### iv. 병행문

* 1개의 프로세스가 여러 가닥의 병렬 프로세스로 분할되었다가 다시 하나로 결합

* perbegin/parend문

* ~~~
  	S0
     ↙ ↓ ↘
    S1 S2 .. Sn
     ↘ ↓ ↙
       Sn+1
  ~~~

#### v. 프로세스 간의 병행성

* 독립적 프로세스
* 비동기 병행 프로세스



## 2. 동기화의 임계 영역

### I. 프로세스 동기화

* 2개 이상의 프로세스에 대한 처리순서를 결정하는 것
  * 예: 동시에 사용할 수 없는 공유 자원, 한 프로세스의 처리 결과에 따라서 다른 프로세서의 처리가 영향을 받는 경우

### II. 임계영역

* 2개 이상의 프로세스가 동시에 엑세스하면 안되는 공유자원을 액세스하는 코드 영역

### III. 상호배제

* 2개 이상의 프로세스가 동시에 임계영역에 진입하지 못하도록 하는 것

### IV. 임계영역을 갖는 프로세스의 일반적 구조

* ~~~
  repeat
  	진입영역
  	임계영역
  	해제영역
  	잔류영역
  until false;
  ~~~


### V. 임계영역 문제 해결을 위한 요구조건

#### i. 상호배제

* 한 프로세스가 임계영역에서 실행 중일 때 다른 어떤 프로세스도 임계영역에서 실행될 수 없음

#### ii. 진행

* 임계영역에서 실행 중인 프로세스가 없고 여러 프로세스가 임계영역에 진입하고자 할 때 그 중에서 적절히 한 프로세스를 결정해야 하며 이 결정은 무한정 미룰 수 없음

#### iii. 제한된 대기

* 한 프로세스가 임계영역 진입 요청을 한 후 수락될 때 까지 다른 프로세스가 임계영역 진입을 허가 받는 횟수는 제한이 있어야 함

  

### VI. 임계영역 문제 해결을 위한 도구

#### i. Test-and-Set 명령어 (TS 명령어)

* 상호배제의 하드웨어적 해결 방법

* **분리가 불가능한 단일 기계 명령어**(원자적으로 수행)

* ~~~
  function Test_and_Set(var target: boolean): boolean;
  	begin
  		Test_and_Set := target;
  		target := true;
       end
  ~~~

* 상호배제의 구현

  * ~~~
    repeat
    	while Test_and_Set(lock) do skip; //lock이 true가 되면 빠져나옴
    	임계영역
    	lock := false;
    	잔류영역
    until false;
    ~~~

  * lock의 초기값은 `false`

* 문제점

  * 많은 프로세스가 임계영역에 들어가기를 원할 때 기아가 발생할 수 있음
    * 기아: 프로세스가 필요한 자원할당을 받지 못하고 계속적으로 대기하게 되는 상황
  * Busy wating을 함으로써 다른 작업이 사용할 수 있는 CPU 사이클을 낭비

#### ii. 세마포어

* Dijkasta가 제안한 동기화 도구

* 세마포어 s: 사용 가능한 자원의 수 또는 잠김/열림 등의 상태를 나타내는 값을 저장하는 정수형 공용변수

* 세마포어 s는 두 표준 단위 연산 P와 V에 의해서만 접근됨

  * P(s): 검사, 감소시키려는 시도

    * ~~~
      if(s > 0) then
      	s := s-1;
      else
      	현재 프로세스 대기;
      ~~~

  * V(s): 증가

    * ~~~
      if (I개 이상의 프로세스 대기 중) then
      	그 중 1개의 프로세스만 진행;
      else
      	s := s+1;
      ~~~

  * 상호배제의 구현

    * ~~~
      repeat
      	P(mutex);
      	임계영역
      	V(mutex);
      	잔류영역
      until false;
      ~~~

    * 세마포어 mutext의 초기값은 `1`

  * 동기화 문제 해결

    * 프로세스 1이 문장 S1을 실행한 후 프로세스2가 문장S2를 실행하도록 동기화(block/wakeup 프로토콜)

      * | 프로세스1         | 프로세스2        |
        | ----------------- | ---------------- |
        | ...               | ...              |
        | S1;               | P(sync); //block |
        | V(sync); //wakeup | S2;              |
        | ...               | ...              |

      * 세마포어 sync의 초기값은 `0`