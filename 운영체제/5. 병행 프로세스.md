# 병행 프로세스

## 1. 프로세스의 상호협력

### 병행 프로세스들의 상호협력

* 공통작업을 수행하기 위해 서로 협동하는 경우

* 예)

  #### I. 생산자/소비자 문제

  * ~~~
    		----버퍼----
    생산자	->  |||||||||   ->	소비자
    		------------
    ~~~

    * 생산자

      * 버퍼에 데이터를 채우는 프로세스
      * 버퍼가 가득 차 있다면 대기해야 함

    * 소비자

      * 버퍼에 있는 데이터를 읽어내는 프로세스
      * 버퍼가 비어있다면 대기해야 함

    * **상호배제 필요**

    * 동기화 필요

      * 세마포어 이용: mutex, empty, full

        * | 생산자 프로세스            | 소비자 ㅍ로세스                          |
          | -------------------------- | ---------------------------------------- |
          | repeat                     | repeat                                   |
          | nextp에 데이터 항목을 생산 | P(full);                                 |
          | P(empty);                  | P(mutex);                                |
          | P(mutex);                  | 버퍼에서 데이터 항목을 꺼내 nextc에 넣음 |
          | nextp를 버퍼에 넣음        | V(mutex);                                |
          | V(mutex);                  | V(empty);                                |
          | V(full);                   | nextc를 소비                             |
          | until false;               | until false;                             |

        * mutex의 초기값 `1`

        * full의 초기값 `0`

        * empty의 초기값 `n`

  #### II. 판독기/기록기 문제

  * ~~~
    기록기1	↘					↙	판독기1
    기록기2	→	공유 데이터 객체	←	판독기2
    기록기3	↗					↖	판독기3
    ~~~

  * 여러개의 판독기가 동시에 공유 데이터 객체에 접근하는 것은 문제가 없음

  * 기록기가 다른 기록기 또는 판독기와 동시에 공유 데이터 객체에 접근하는 것은 문제

  * **상호배제 필요**

  * 우선 순위에 따른 문제의 변형

    * 제1 판독기/기록기 문제 (판독기 우선)

      * 기록기가 이미 공유 객체의 사용을 허가 받은 것이 아니라면 판독기는 대기하지 않음

        * **기록기의 기아상태 유발 가능**

      * 세마포어 이용: mutex, wrt

        * | 기록기 프로세스 | 판독기 프로세스               |
          | --------------- | ----------------------------- |
          |                 | P(mutex)                      |
          |                 | readcount := readcount + 1;   |
          |                 | if readcount = 1 then P(wrt); |
          | P(wrt)          | V(mutex)                      |
          | **쓰기 수행**   | **읽기 수행**                 |
          | V(wrt)          | P(mutex)                      |
          |                 | readcount := readcount - 1    |
          |                 | if readcount = 0 then V(wrt); |
          |                 | V(mutex)                      |

        * wrt의 초기값 `1`

        * 변수 readcount의 초기값 `0`

    * 제2 판독기/기록기 문제 (기록기 우선)

      * 일단 기록기가 준비되었다면 기록을 가능한 빨리 수행할 수 있도록 함
        * **판독기의 기아상태 유발 가능**

## 2. 프로세스 간의 통신

### I. 병행 프로세스 사이의 통신을 위한 방법

* 공유 기억장치 기법
* 메세지 시스템 기법
* 두 방법은 상호 배타적이 아님
* 단일 운영체제 내에서 동시에 사용 가능

#### i. 공유 기억장치 기법

* 프로세스 간에 공유 변수를 이용하여 정보를 교환

* 고속 통신 가능

* 통신 기능 제공의 책임: 응용 프로그래머

* |   프로세스A   |
  | :-----------: |
  | 공유기억장치  |
  | **프로세스B** |
  |      ...      |
  |   **커널**    |

#### ii. 메시지 시스템 기법

* 메시지 교환 방식으로 정보를 교환

* send/receive 연산자

* 소량의 데이터 교환에 유용

* 통신 기능 제공의 책임: 운영체제

* |   프로세스A   |
  | :-----------: |
  | **프로세스B** |
  |      ...      |
  |     커널      |

#### 통신링크

* 프로세스들 사이에 메세지를 주고받기 위한 연결 통로

* ~~~
  			통신링크
  프로세스P =============== 프로세스Q
  ~~~

* 논리적 구현에 대한 이슈

  * 어떻게 링크를 설정?
  * 한 링크가 2개 이상의 프로세스와 연결 가능?
  * 두 프로세스 사이에 얼마나 많은 링크 존재?
  * 링크의 용량? 메시지 크기? 링크는 단방향? 양방향?

#### 직접 통신

* 메시지 전달 연산에 수신자나 송신자 이름을 명시
* 통신 링크는 자동 설정됨
* 하나의 링크는 두 프로세스 사이만 연관되며 각 통신 프로세스 쌍 사이에는 정확히 하나의 링크가 존재
* 링크는 양방향임
* 대칭형
  * 주고 받는 곳을 명시적으로 씀
* 비대칭형
  * 받는 곳에서 변수를 사용해서 받음

#### 간접 통신

* 메세지 전달 연산에 우편함 이름을 표시

* 통신 링크는 2개 이상의 프로세스들과 연관될 수 있으며

* 각 통신 프로세스 쌍 사이에는 여러 링크가 존재 가능

* 링크는 단방향 또는 양방향임

* 우편함이 프로세스에 소속되는 경우

  * 우편함을 소유하고 있는 프로세스는 수신만 가능, 나머지는 송신만 가능 (단방향 통신)

* 우편함이 운영체제에 소속되는 경우

  * 우편함의 소유권을 주고 받으며 송수신을 함 (양방향 통신)

* 링크의 용량

  * '0' 용량 (동기화 필요)
  * 제한된 용량 (자동 버퍼링)
    * 큐가 가득 차면 송신자는 대기
  * 무제한 용량 (자동 버퍼링)
    * 송신자가 대기할 필요 없음
  * '0' 용량이 아닌 경우 메시지 도착 여부의 인지 방법
    * 메시지를 받은 프로세스에서 'ack'라는 답신을 보냄 (비동기적 통신)

  



### II. 예외조건 처리

#### i. 프로세스 종료

*  송신 프로세스가 종료된 경우
  * 수신 프로세스 종료
  * 송신 프로세스가 종료한 사실을 수신 프로세스에게 알림
* 수신 프로 세스가 종료된 경우
  * 버퍼가 없는 경우
    * 송신 프로세스를 종료ㄴ
    * 수신 프로세스가 종료한 사실을 송신 프로세스에게 알림

#### ii. 메시지 상실

* 운영체제가 탐지 후 메시지 재전송
* 송신 프로세스가 탐지 후 메시지 재전송
* 운영체제가 탐지 후 송신 프로세스에게 통지
* 탐지방법: 시간 제한



##### iii. 메시지 혼합

* 오류 탐지 후 재전송
* 탐지방법
  * checksum
  * 메시지에 해당하는 bit값을 보내줘서 확인