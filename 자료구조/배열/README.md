# 배열



## 정의



배열은 **인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합**으로, 정의된 각 인덱스는 그 인덱스와 관련된 값을 가진다. 또한 배열의 **원소들은 모두 같은 자료형**을 가지기 때문에 메모리의 크기가 모두 같다. 각 원소의 물리적 위치와 논리적 위치(인덱스)의 순서는 일치하고 원소에 접근시 인덱스의 값을 이용하기 때문에 **직접 접근**(*direct access*)라고 한다. 인덱스란 추상화된 값(컴퓨터의 내부 구조나 메모리 주소와 무관하게 개념적으로 정의)이며 실제 메모리의 주소값은 16진수로 구성되어있는 실제 반도체의 물리적인 주소값이다. 따라서 운영체제는 접근하려는 원소의 인덱스를 이용하여 실제 메모리 주소를 계산한다.



#### 메모리의 주소값과 인덱스의 관계

인덱스는 사람이 이해하고 직관적으로 받아들이기 쉽게하기 위해 정의한 값이다. 그렇게 추상화된 값을 컴퓨터가 해석하여 물리적인 값으로 변환하고, 이를 전기 신호로 바꾸어 주소를 계산한다. **배열의 물리적인 저장 순서는 배열의 인덱스에 의해 결정**되며, 그 순서가 바로 메인 메모리에서 저장 위치의 순서가 된다. 실제로 사용되는 메모리의 각 영역에는 16진수로된 주소가 부여되어 있어서 프로그램을 작성하고 실행시키면 16진수 값의 주소를 찾아내서 데이터를 찾아오고 저장하게 되는 것이다.



### 배열 맛보기

배열은 인덱스와 값의 쌍으로 이루어져 있고 인덱스는 순서를 나타내는 원소의 유한 집합을 의미한다. 배열의 크기는 개발자가 정하기 때문에 배열의 인덱스 범위가 정해진다. 예를 들어 배열의 크기를 3으로 지정한다면 인덱스 i의 값은 [0], [1], [2]의 순서로 정해진다. 그리고 값을 나타내는 원소는 같은 자료형의 집합이기 때문에 int형으로 배열을 선언하게 되면 모든 원소의 크기는 int의 크기와 같다.

~~~c
int arr[]; //크기가 4인 정수형 배열
arr[0] = 1;
~~~

위의 코드에서 `arr`은 배열의 이름, `4`는 배열의 크기, `arr[0] = 1;`은 배열의 0번째에 있는 공간에 정수 1을 할당한 것이다. 나머지 1, 2 번째 인덱스에는 아직 값이 할당되지 않은 상태이고 만약 할당되지 않은 상태에서 참조를 하게 된다면 에러메세지를 반환하게 된다. 



### 배열의 연산 구현 예제

#### 배열 생성 함수

~~~c
1 void create(int n) { // n = 5
2     int a[n];
3     int i;
4     for (i = 0; i < n; i++) {
5         a[i] = 0;
6     }
7 }
~~~

2행에서 다섯개의 원소를 저장할 수 있는 배열의 메모리 공간을 정의하고 4~6행 반복문에서 초기값으로 0을 할당해줌  



##### 배열 생성 결과

![01](image/01.png)



#### 배열 검색, 저장 함수

![02](image/02.png)

##### 검색연산

~~~c
1 #define array_size = 5
2 int retrieve(int *a, int i) { // i = 2
3     if (i >= 0 && i < array_size){
4         return a[i];
5     } else {
6         printf("Error \n");
7         return (-1);
8     }
9 }
~~~

1 인덱스의 범위를 #define 함수로 정의

2 배열을 가리키는 변수 a와  반환할 원소의 값의 위치를 가리키는 i 변수의 값을 매개변수로 전달받음

3-4 i의 값이 인덱스 유효 집합 범위 내에 있는지 확인. 여기서는 참이므로 `a[2]`의 값인 30을 반환

6~7 i가 인덱스 유효 집합 범위에 해당하지 않으면 에러메세지 출력 후 범위가 잘못되었음을 알리는 -1을 반환하고 종료



##### 저장 연산

~~~c
1 #define array_size = 5
2 void store(int *a, int i, int e) { // i = 3, e = 35
3     if (i > 0 && i < array_size) {
4         a[i] = e;
5     } else {
6         printf("Error \n");
7     }
8 }
~~~

1 인덱스의 범위를 #define 함수로 정의

2 배열을 가리키는 변수 a와  원소 e를 저장할 원소값의 위치를 가리키는 i, 배열에 저장할 원소값 e를 매개변수로 전달받음

3-4 i의 값이 인덱스 유효 집함 범위 내에 있는지 확인, 여기서는 참이므로 `a[3]`에 35를 할당 후 종료

6 i가 인덱스 유효 집합 범위에 해당하지 않으면 에러메세지 출력 후 종료



##### 실행 결과

![03](image/03.png)