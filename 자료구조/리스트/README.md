# 연결 리스트(Linked List)

리스트는 **일정한 순서가 있는 자료구조**이다. 배열은 논리적 순서와 물리적 순서가 일치해야 하지만 리스트는 **논리적인 순서만 유지주면 된다.** 리스트는 배열을 사용하여 구현하는 방법과 원소값을 저장하는 공간과 다음 원소를 가리키는 위치 정보를 저장하는 공간을 구현하는 방법, 이렇게 두가지가 있다.

## 배열을 이용한 리스트 구현

배열로 리스트를 구현하는 방법은 간단하다. 1차원 배열을 사용하여 저장하는 것이다. 배열을 이용하여 구현하는 것은 상대적으로 간단하며, 포인터를 위한 공간이 필요없기 때문에 메모리 공간 활용 효율도 높다. 하지만 **배열로 구현하였기 때문에 물리적 순서와 논리적 순서가 일치**한다. 그렇기 때문에 **원소의 삽입이나 삭제에 시간이 많이 소요**될 수 있다. 예를 들면 200개의 요소가 들어있는 리스트 2번째에 요소를 삽입하면 199개는 한칸씩 뒤로 밀려야하고, 삭제가 발생한다면 삭제된 요소 뒤의 요소들은 한 칸씩 다시 앞당겨져야 한다. 프로그램 실행 중에 시간이 소요가 많이 되기 때문에 자주 사용되는 방식은 아니다.

## 포인터를 이용한 리스트 구현

포인터를 이용한 방식은 원소의 자리에는 원소를 저장하고, 다음 원소를 가리키는 정보의 자리에는 다음 원소가 저장될 주소값을 저장한다. 이 쌍을 *노드*라고 표현을 하며, *노드*에는 데이터와, 다음 요소를 가리키는 포인터(링크)가 저장되어있다고 생각하면 된다.

![01](images/01.png)

위의 그림과 같이 주소값은 연속될 필요가 없고 드문드문 저장되어도 노드에 저장되어 있는 포인터를 이용하여 다음 노드를 찾아갈 수 있다. 포인터를 이용하여 구현되는 리스트를 **연결 리스트**라고 한다.

![02](images/02.png)

**연결 리스트는 노드간의 포인터 연결을 통해서 구현**되며, 각 노드는 적어도 두 종류의 필드, **원소값을 저장하는 데이터필드와 노드 연결을 위한 링크 필드를 가진다.** 위 그림에서 보이는 `head`요소는 연결 리스트의 시작 노드를 가리키며, 마지막 노드를 제외한 나머지 노드는 논리적으로 다음에 위치하는 노드를 가리키는 주소를 가지게 된다. 마지막 링크는 널 포인터(*null pointer*)로 표현한다.

## 연결 리스트에서 노드의 삽입과 삭제

### 노드의 삭제

A의 요소를 가지고 있는 노드의 포인터 변수가 가리키는 노드(B)를 삭제하기 위해서는 B를 가리키고 있는 선행 노드(A)의 연결을 끊고 B의 후행노드(C)로 연결시켜 주면 된다.

![03](images/03.png)

### 노드의 삽입

![04](images/04.png)
노드의 삽입은 삭제보다는 조금 복잡한데, 아래와 같이 A, B, C를 가지고 있는 노드들이 있다고 했을 때, B와 C사이에 노드를 삽입하려면 아래의 그림과 같이 먼저 노드를 하나 생성한 뒤.
![05](images/05.png)
다시 아래의 그림처럼 B와 C사이의 링크를 끊고 B는 D로 연결, D는 다시 C로 연결하여 삽입을 하면된다.
![06](images/06.png)
논리적 순서만 일치하면 되므로 위와 같이 물리적 순서가 맞지 않더라도 상관이 없다.